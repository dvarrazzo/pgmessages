# Korean message translation file for PostgreSQL pg_dump
# Ioseph Kim <ioseph@uri.sarang.net>, 2004.
#
msgid ""
msgstr ""
"Project-Id-Version: PostgreSQL 8.0\n"
"POT-Creation-Date: 2004-12-17 01:33+0000\n"
"PO-Revision-Date: 2004-12-18 01:36+0900\n"
"Last-Translator: Ioseph Kim <ioseph@uri.sarang.net>\n"
"Language-Team: Korean <pgsql-kr@postgresql.or.kr>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=euc-kr\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Poedit-Language: Korean\n"
"X-Poedit-Country: KOREA, REPUBLIC OF\n"

#: pg_dump.c:364
#: pg_restore.c:229
msgid "User name: "
msgstr "사용자 이름:"

#: pg_dump.c:400
#: pg_dumpall.c:264
#: pg_restore.c:256
#, c-format
msgid "%s: invalid -X option -- %s\n"
msgstr "%s: 잘못된 -X 옵션 -- %s\n"

#: pg_dump.c:402
#: pg_dump.c:416
#: pg_dump.c:425
#: pg_dumpall.c:266
#: pg_dumpall.c:275
#: pg_dumpall.c:292
#: pg_restore.c:258
#: pg_restore.c:268
#: pg_restore.c:285
#, c-format
msgid "Try \"%s --help\" for more information.\n"
msgstr "보다 자세한 사용법은 \"%s --help\"\n"

#: pg_dump.c:423
#: pg_dumpall.c:290
#, c-format
msgid "%s: too many command-line arguments (first is \"%s\")\n"
msgstr "%s: 너무 많은 명령행 인자들 (시작 \"%s\")\n"

#: pg_dump.c:436
msgid "options \"schema only\" (-s) and \"data only\" (-a) cannot be used together\n"
msgstr "-s 옵션과 -a 옵션은 함께 사용될 수 없습니다.\n"

#: pg_dump.c:442
msgid "options \"clean\" (-c) and \"data only\" (-a) cannot be used together\n"
msgstr "-c 옵션과 -a 옵션은 함께 사용할 수 없습니다.\n"

#: pg_dump.c:448
msgid "large-object output not supported for a single table\n"
msgstr "large-object 출력은 단일 테이블 작업에서는 지원하지 않습니다\n"

#: pg_dump.c:449
#: pg_dump.c:456
msgid "use a full dump instead\n"
msgstr "대신에 전체 덤프를 사용하십시오.\n"

#: pg_dump.c:455
msgid "large-object output not supported for a single schema\n"
msgstr "large-object 출력은 단일 SCHEMA 작업에서는 지원하지 않습니다\n"

#: pg_dump.c:462
msgid "INSERT (-d, -D) and OID (-o) options cannot be used together\n"
msgstr "INSERT (-d, -D) 옵션과 OID (-o) 옵션은 함께 사용될 수 없습니다\n"

#: pg_dump.c:463
msgid "(The INSERT command cannot set OIDs.)\n"
msgstr "(INSERT 명령으로는 OID 값을 입력할 수 없음.)\n"

#: pg_dump.c:469
msgid "large-object output is not supported for plain-text dump files\n"
msgstr "large-object 출력은 plain-text 덤프 파일 형태에서는 지원하지 않음\n"

#: pg_dump.c:470
msgid "(Use a different output format.)\n"
msgstr "(다른 출력 파일 형태를 사용하세요.)\n"

#: pg_dump.c:499
#, c-format
msgid "invalid output format \"%s\" specified\n"
msgstr "\"%s\" 값은 잘못된 출력 파일 형태입니다.\n"

#: pg_dump.c:505
#, c-format
msgid "could not open output file \"%s\" for writing\n"
msgstr "\"%s\" 파일을 쓰기 모드로 열 수 없음\n"

#: pg_backup_db.c:52
#: pg_dump.c:516
#, c-format
msgid "could not parse version string \"%s\"\n"
msgstr "\"%s\" 버전 문자열을 분석할 수 없음\n"

#: pg_dump.c:552
#, c-format
msgid "last built-in OID is %u\n"
msgstr "마지막 내장 OID는 %u\n"

#: pg_dump.c:663
#, c-format
msgid ""
"%s dumps a database as a text file or to other formats.\n"
"\n"
msgstr ""
"%s 프로그램은 데이터베이스를 텍스트 파일 또는 기타\n"
"다른 형태의 파일로 덤프합니다.\n"
"\n"

#: pg_dump.c:664
#: pg_dumpall.c:337
#: pg_restore.c:359
msgid "Usage:\n"
msgstr "사용법:\n"

#: pg_dump.c:665
#, c-format
msgid "  %s [OPTION]... [DBNAME]\n"
msgstr "  %s [옵션]... [DB이름]\n"

#: pg_dump.c:667
#: pg_dumpall.c:340
#: pg_restore.c:362
msgid ""
"\n"
"General options:\n"
msgstr ""
"\n"
"일반 옵션들:\n"

#: pg_dump.c:668
#: pg_restore.c:364
msgid "  -f, --file=FILENAME      output file name\n"
msgstr "  -f, --file=FILENAME      출력 파일 이름\n"

#: pg_dump.c:669
msgid "  -F, --format=c|t|p       output file format (custom, tar, plain text)\n"
msgstr "  -F, --format=c|t|p       출력파일 형태 (custom, tar, plain text)\n"

#: pg_dump.c:670
msgid ""
"  -i, --ignore-version     proceed even when server version mismatches\n"
"                           pg_dump version\n"
msgstr ""
"  -i, --ignore-version     서버 버전과, pg_dump 버전이 서로 틀려도\n"
"                           무시하고 진행함\n"

#: pg_dump.c:672
#: pg_restore.c:368
msgid "  -v, --verbose            verbose mode\n"
msgstr "  -v, --verbose            자세한 정보 보여줌\n"

#: pg_dump.c:673
msgid "  -Z, --compress=0-9       compression level for compressed formats\n"
msgstr "  -Z, --compress=0-9       압축되는 파일 형태의 압축률\n"

#: pg_dump.c:674
#: pg_dumpall.c:343
#: pg_restore.c:369
msgid "  --help                   show this help, then exit\n"
msgstr "  --help                   이 도움말을 보여주고 마침\n"

#: pg_dump.c:675
#: pg_dumpall.c:344
#: pg_restore.c:370
msgid "  --version                output version information, then exit\n"
msgstr "  --version                버전 정보를 보여주고 마침\n"

#: pg_dump.c:677
#: pg_dumpall.c:345
msgid ""
"\n"
"Options controlling the output content:\n"
msgstr ""
"\n"
"출력 내용을 다루는 옵션들:\n"

#: pg_dump.c:678
#: pg_dumpall.c:346
msgid "  -a, --data-only          dump only the data, not the schema\n"
msgstr "  -a, --data-only          스키마 빼고 자료만 덤프\n"

#: pg_dump.c:679
msgid "  -b, --blobs              include large objects in dump\n"
msgstr "  -b, --blobs              Large Object들도 함께 덤프함\n"

#: pg_dump.c:680
#: pg_restore.c:374
msgid "  -c, --clean              clean (drop) schema prior to create\n"
msgstr "  -c, --clean              덤프가 끝나면 해당 스키마들을 삭제함\n"

#: pg_dump.c:681
msgid "  -C, --create             include commands to create database in dump\n"
msgstr "  -C, --create             데이터베이스 만드는 명령구문도 포함시킴\n"

#: pg_dump.c:682
#: pg_dumpall.c:348
msgid "  -d, --inserts            dump data as INSERT, rather than COPY, commands\n"
msgstr "  -d, --inserts            자료 입력 명령을 COPY 명령대신 INSERT 사용\n"

#: pg_dump.c:683
#: pg_dumpall.c:349
msgid "  -D, --column-inserts     dump data as INSERT commands with column names\n"
msgstr "  -D, --column-inserts     INSERT 명령을 사용하는데 칼럼 이름도 포함\n"

#: pg_dump.c:684
msgid "  -n, --schema=SCHEMA      dump the named schema only\n"
msgstr "  -n, --schema=SCHEMA      지정한 SCHEMA 자료만 덤프\n"

#: pg_dump.c:685
#: pg_dumpall.c:351
msgid "  -o, --oids               include OIDs in dump\n"
msgstr "  -o, --oids               OID 포함해서 덤프\n"

#: pg_dump.c:686
msgid ""
"  -O, --no-owner           skip restoration of object ownership\n"
"                           in plain text format\n"
msgstr ""
"  -O, --no-owner           plain text 형식 덤프에서\n"
"                           객체의 소유주 지정하는 부분은 통과\n"

#: pg_dump.c:688
#: pg_dumpall.c:353
msgid "  -s, --schema-only        dump only the schema, no data\n"
msgstr "  -s, --schema-only        자료구조(스키마)만 덤프\n"

#: pg_dump.c:689
msgid ""
"  -S, --superuser=NAME     specify the superuser user name to use in\n"
"                           plain text format\n"
msgstr ""
"  -S, --superuser=NAME     plain text 형식 덤프에서\n"
"                           슈퍼유저로 작업할 사용자 이름 지정\n"

#: pg_dump.c:691
msgid "  -t, --table=TABLE        dump the named table only\n"
msgstr "  -t, --table=TABLE        지정한 이름의 테이블만 덤프\n"

#: pg_dump.c:692
#: pg_dumpall.c:355
msgid "  -x, --no-privileges      do not dump privileges (grant/revoke)\n"
msgstr "  -x, --no-privileges      접근권한 (grant/revoke) 정보는 덤프 안 함\n"

#: pg_dump.c:693
#: pg_dumpall.c:356
msgid ""
"  -X disable-dollar-quoting, --disable-dollar-quoting\n"
"                           disable dollar quoting, use SQL standard quoting\n"
msgstr ""
"  -X disable-dollar-quoting, --disable-dollar-quoting\n"
"                           달러 인용표기를 사용 안 함, 표준 인용표기 사용\n"

#: pg_dump.c:695
#: pg_dumpall.c:358
#: pg_restore.c:388
msgid ""
"  -X disable-triggers, --disable-triggers\n"
"                           disable triggers during data-only restore\n"
msgstr ""
"  -X disable-triggers, --disable-triggers\n"
"                           데이터를 입력하는 동안 트리거 작동을 막음\n"

#: pg_dump.c:697
#: pg_dumpall.c:360
#: pg_restore.c:390
msgid ""
"  -X use-set-session-authorization, --use-set-session-authorization\n"
"                           use SESSION AUTHORIZATION commands instead of\n"
"                           OWNER TO commands\n"
msgstr ""
"  -X use-set-session-authorization, --use-set-session-authorization\n"
"                           OWNER TO 명령 대신에 SESSION AUTHORIZATION\n"
"                           명령을 사용\n"

#: pg_dump.c:701
#: pg_dumpall.c:364
#: pg_restore.c:394
msgid ""
"\n"
"Connection options:\n"
msgstr ""
"\n"
"연결 옵션들:\n"

#: pg_dump.c:702
#: pg_dumpall.c:365
#: pg_restore.c:395
msgid "  -h, --host=HOSTNAME      database server host or socket directory\n"
msgstr "  -h, --host=HOSTNAME      접속할 데이터베이스 서버 또는 소켓 디렉토리\n"

#: pg_dump.c:703
#: pg_dumpall.c:366
#: pg_restore.c:396
msgid "  -p, --port=PORT          database server port number\n"
msgstr "  -p, --port=PORT          데이터베이스 서버의 포트 번호\n"

#: pg_dump.c:704
#: pg_dumpall.c:367
#: pg_restore.c:397
msgid "  -U, --username=NAME      connect as specified database user\n"
msgstr "  -U, --username=NAME      연결할 데이터베이스 사용자\n"

#: pg_dump.c:705
#: pg_dumpall.c:368
#: pg_restore.c:398
msgid "  -W, --password           force password prompt (should happen automatically)\n"
msgstr "  -W, --password           비밀번호 입력 프롬프트 보임(자동으로 처리함)\n"

#: pg_dump.c:707
msgid ""
"\n"
"If no database name is supplied, then the PGDATABASE environment\n"
"variable value is used.\n"
"\n"
msgstr ""
"\n"
"데이터베이스 이름을 지정하지 않았다면, PGDATABASE 환경변수값을\n"
"사용합니다.\n"
"\n"

#: pg_dump.c:709
#: pg_dumpall.c:371
#: pg_restore.c:402
msgid "Report bugs to <pgsql-bugs@postgresql.org>.\n"
msgstr "오류보고: <pgsql-bugs@postgresql.org>.\n"

#: pg_backup_archiver.c:1219
#: pg_dump.c:717
msgid "*** aborted because of error\n"
msgstr "*** 오류 때문에 중지되었음\n"

#: pg_dump.c:799
#, c-format
msgid "dumping contents of table %s\n"
msgstr "%s 테이블의 내용을 덤프 중입니다\n"

#: pg_dump.c:911
#, c-format
msgid "SQL command to dump the contents of table \"%s\" failed: PQendcopy() failed.\n"
msgstr "\"%s\" 테이블 내용을 덤프하는 SQL 명령에서 오류 발생: PQendcopy() 실패.\n"

#: pg_dump.c:912
#: pg_dump.c:8100
#, c-format
msgid "Error message from server: %s"
msgstr "서버에서 보낸 오류 메시지: %s"

#: pg_dump.c:913
#: pg_dump.c:8101
#, c-format
msgid "The command was: %s\n"
msgstr "사용된 명령: %s\n"

#: pg_dump.c:1184
msgid "saving database definition\n"
msgstr "데이터베이스 구성정보를 저장중입니다\n"

#: pg_dump.c:1230
#, c-format
msgid "missing pg_database entry for database \"%s\"\n"
msgstr "\"%s\" 데이터베이스의 정보를 pg_database에서 찾을 수 없음\n"

#: pg_dump.c:1237
#, c-format
msgid "query returned more than one (%d) pg_database entry for database \"%s\"\n"
msgstr "pg_database에는 한 개 이상(%d)의 \"%s\" 데이터베이스 정보가 있음\n"

#: pg_dump.c:1345
msgid "saving encoding\n"
msgstr "인코딩을 저장 중입니다\n"

#: pg_dump.c:1395
msgid "saving large objects\n"
msgstr "large object들을 저장 중입니다\n"

#: pg_dump.c:1428
#, c-format
msgid "dumpBlobs(): could not open large object: %s"
msgstr "dumpBlobs(): large object를 열 수 없음: %s"

#: pg_dump.c:1441
#, c-format
msgid "dumpBlobs(): error reading large object: %s"
msgstr "dumpBlobs(): large object 읽는 중 오류: %s"

#: pg_dump.c:1558
#, c-format
msgid "WARNING: owner of schema \"%s\" appears to be invalid\n"
msgstr "경고: \"%s\" 스키마의 소유주가 바르지 않습니다\n"

#: pg_dump.c:1575
#, c-format
msgid "specified schema \"%s\" does not exist\n"
msgstr "지정한 \"%s\" 스키마가 없습니다.\n"

#: pg_dump.c:1612
#, c-format
msgid "schema with OID %u does not exist\n"
msgstr "OID가 %u 인 스키마가 없습니다.\n"

#: pg_dump.c:1797
#, c-format
msgid "WARNING: owner of data type \"%s\" appears to be invalid\n"
msgstr "경고: \"%s\" 자료형의 소유주가 적당하지 않습니다.\n"

#: pg_dump.c:1895
#, c-format
msgid "WARNING: owner of operator \"%s\" appears to be invalid\n"
msgstr "경고: \"%s\" 연산자의 소유주가 적당하지 않습니다.\n"

#: pg_dump.c:2061
#, c-format
msgid "WARNING: owner of operator class \"%s\" appears to be invalid\n"
msgstr "WARNING: \"%s\" 연산자 클래스의 소유주가 적당하지 않습니다.\n"

#: pg_dump.c:2165
#, c-format
msgid "WARNING: owner of aggregate function \"%s\" appears to be invalid\n"
msgstr "WARNING: \"%s\" 집계 함수의 소유주가 적당하지 않습니다.\n"

#: pg_dump.c:2299
#, c-format
msgid "WARNING: owner of function \"%s\" appears to be invalid\n"
msgstr "WARNING: \"%s\" 함수의 소유주가 적당하지 않습니다.\n"

#: pg_dump.c:2577
#, c-format
msgid "WARNING: owner of table \"%s\" appears to be invalid\n"
msgstr "WARNING: \"%s\" 테이블의 소유주가 적당하지 않습니다.\n"

#: pg_dump.c:2596
#, c-format
msgid "specified table \"%s\" does not exist\n"
msgstr "지정한 \"%s\" 테이블이 없습니다\n"

#: pg_dump.c:2703
#, c-format
msgid "reading indexes for table \"%s\"\n"
msgstr "\"%s\" 테이블에서 사용하는 인덱스들을 찾는 중 입니다\n"

#: pg_dump.c:2940
#, c-format
msgid "reading foreign key constraints for table \"%s\"\n"
msgstr "\"%s\" 테이블에서 사용하는 참조키 제약조건을 찾는 중입니다\n"

#: pg_dump.c:3225
#, c-format
msgid "reading triggers for table \"%s\"\n"
msgstr "\"%s\" 테이블에서 사용하는 트리거들을 찾는 중입니다\n"

#: pg_dump.c:3297
#, c-format
msgid "expected %d triggers on table \"%s\" but found %d\n"
msgstr "%d개의 트리거가 \"%s\" 테이블에서 지정되었지만 %d 밖에 찾지 못했습니다\n"

#: pg_dump.c:3342
#, c-format
msgid "query produced null referenced table name for foreign key trigger \"%s\" on table \"%s\" (OID of table: %u)\n"
msgstr "쿼리가 참조테이블 정보가 없는 \"%s\" 참조키 트리거를 \"%s\" (해당 OID: %u) 테이블에서 만들었습니다.\n"

#: pg_dump.c:3643
#, c-format
msgid "finding the columns and types of table \"%s\"\n"
msgstr "\"%s\" 테이블의 칼럼과 자료형을 조사중\n"

#: pg_dump.c:3729
#, c-format
msgid "invalid column numbering in table \"%s\"\n"
msgstr "\"%s\" 테이블에 매겨져 있는 칼럼 번호가 잘못되었습니다\n"

#: pg_dump.c:3763
#, c-format
msgid "finding default expressions of table \"%s\"\n"
msgstr "\"%s\" 테이블에서 default 표현들 찾는 중\n"

#: pg_dump.c:3846
#, c-format
msgid "invalid adnum value %d for table \"%s\"\n"
msgstr "적당하지 않는 adnum 값: %d, 해당 테이블 \"%s\"\n"

#: pg_dump.c:3864
#, c-format
msgid "finding check constraints for table \"%s\"\n"
msgstr "\"%s\" 테이블에서 사용하는 체크 제약조건을 찾는 중\n"

#: pg_dump.c:3928
#, c-format
msgid "expected %d check constraints on table \"%s\" but found %d\n"
msgstr "%d개의 체크 제약조건을 \"%s\" 테이블에서 있다고 하는데, %d개를 찾았음\n"

#: pg_dump.c:3930
msgid "(The system catalogs might be corrupted.)\n"
msgstr "(시스템 카타로그가 손상되었는 것 같습니다)\n"

#: pg_dump.c:4628
#: pg_dump.c:4794
#: pg_dump.c:5195
#: pg_dump.c:5581
#: pg_dump.c:5880
#: pg_dump.c:6082
#: pg_dump.c:6267
#, c-format
msgid "Got %d rows instead of one from: %s"
msgstr "하나의 로우를 뽑아야하는데 %d개의 로우가 뽑혔습니다, 출처: %s"

#: pg_dump.c:4903
#, c-format
msgid "query yielded no rows: %s\n"
msgstr "쿼리 결과가 비었습니다: %s\n"

#: pg_dump.c:5251
msgid "WARNING: could not parse proargnames array\n"
msgstr "경고: proargnames 배열을 분석할 수 없습니다\n"

#: pg_dump.c:5288
#, c-format
msgid "unrecognized provolatile value for function \"%s\"\n"
msgstr "\"%s\" 함수의 provolatile 값이 잘못 되었습니다\n"

#: pg_dump.c:5805
#, c-format
msgid "WARNING: could not find operator with OID %s\n"
msgstr "경고: %s OID의 연산자를 찾을 수 없음\n"

#: pg_dump.c:6295
#, c-format
msgid "WARNING: aggregate function %s could not be dumped correctly for this database version; ignored\n"
msgstr "경고: %s 집계 함수는 이 데이터베이스 버전에서는 바르게 덤프되질 못했습니다; 무시함\n"

#: pg_dump.c:6429
#, c-format
msgid "could not parse ACL list (%s) for object \"%s\" (%s)\n"
msgstr "ACL 목록 (%s)을 분석할 수 없음, 해당 객체: \"%s\" (%s)\n"

#: pg_dump.c:6523
#, c-format
msgid "query to obtain definition of view \"%s\" returned no data\n"
msgstr "\"%s\" 뷰 정의 정보가 없습니다\n"

#: pg_dump.c:6526
#, c-format
msgid "query to obtain definition of view \"%s\" returned more than one definition\n"
msgstr "\"%s\" 뷰 정의 정보가 하나 이상 있습니다.\n"

#: pg_dump.c:6535
#, c-format
msgid "definition of view \"%s\" appears to be empty (length zero)\n"
msgstr "\"%s\" 뷰의 정의 내용이 비어있습니다\n"

#: pg_dump.c:6848
#, c-format
msgid "invalid column number %d for table \"%s\"\n"
msgstr "잘못된 칼럼 번호 %d, 해당 테이블 \"%s\"\n"

#: pg_dump.c:6951
#, c-format
msgid "missing index for constraint \"%s\"\n"
msgstr "\"%s\" 제약조건을 위한 인덱스가 빠졌습니다\n"

#: pg_dump.c:7111
#, c-format
msgid "unrecognized constraint type: %c\n"
msgstr "알 수 없는 제약 조건 종류: %c\n"

#: pg_dump.c:7168
msgid "inserted invalid OID\n"
msgstr "삽입된 부당한 OID\n"

#: pg_dump.c:7174
#, c-format
msgid "maximum system OID is %u\n"
msgstr "최대 시스템 OID는 %u\n"

#: pg_dump.c:7215
msgid "missing pg_database entry for this database\n"
msgstr "pg_database에서 이 데이터베이스에 대한 항목을 찾을 수 없음\n"

#: pg_dump.c:7220
msgid "found more than one pg_database entry for this database\n"
msgstr "pg_database에서 이 데이터베이스에 대한 항목을 하나 이상 찾았음\n"

#: pg_dump.c:7252
msgid "could not find entry for pg_indexes in pg_class\n"
msgstr "pg_class에서 pg_indexes 항목을 찾을 수 없음\n"

#: pg_dump.c:7257
msgid "found more than one entry for pg_indexes in pg_class\n"
msgstr "pg_class에서 pg_indexes 항목을 하나 이상 찾았음\n"

#: pg_dump.c:7306
#, c-format
msgid "query to get data of sequence \"%s\" returned %d rows (expected 1)\n"
msgstr "\"%s\" 시퀀스 정보를 찾는 쿼리가 %d개의 로우를 리턴했습니다(1개만 리턴해야함)\n"

#: pg_dump.c:7315
#, c-format
msgid "query to get data of sequence \"%s\" returned name \"%s\"\n"
msgstr "\"%s\" 시퀀스의 자료를 구하는 쿼리가 \"%s\" 이름을 리턴했음\n"

#: pg_dump.c:7556
#, c-format
msgid "invalid argument string (%s) for trigger \"%s\" on table \"%s\"\n"
msgstr "잘못된 인자 문자열 (%s), 해당 트리거 \"%s\", 사용되는 테이블 \"%s\"\n"

#: pg_dump.c:7663
#, c-format
msgid "query to get rule \"%s\" for table \"%s\" failed: wrong number of rows returned"
msgstr "\"%s\" 룰을 구하는 쿼리가 실패했음: 잘못된 row 갯수를 리턴했음, 해당 테이블 \"%s\""

#: pg_dump.c:7731
msgid "reading dependency data\n"
msgstr "의존 관계 자료 읽는 중\n"

#: pg_dump.c:7908
#, c-format
msgid "query yielded %d rows instead of one: %s\n"
msgstr "쿼리가 한 개가 아니라, %d개의 로우를 구했음: %s\n"

#: pg_dump.c:8095
msgid "SQL command failed\n"
msgstr "SQL 명령 실패\n"

#: common.c:99
msgid "reading schemas\n"
msgstr "스키마들을 읽는 중\n"

#: common.c:103
msgid "reading user-defined functions\n"
msgstr "사용자 정의 함수들 읽는 중\n"

#: common.c:108
msgid "reading user-defined types\n"
msgstr "사용자 정의 자료형을 읽는 중\n"

#: common.c:113
msgid "reading procedural languages\n"
msgstr "프로시쥬얼 언어를 읽는 중\n"

#: common.c:117
msgid "reading user-defined aggregate functions\n"
msgstr "사용자 정의 집계 함수를 읽는 중\n"

#: common.c:121
msgid "reading user-defined operators\n"
msgstr "사용자 정의 연산자를 읽는 중\n"

#: common.c:125
msgid "reading user-defined operator classes\n"
msgstr "사용자 정의 연산자 클래스를 읽는 중\n"

#: common.c:129
msgid "reading user-defined conversions\n"
msgstr "사용자 정의 인코딩 변환규칙을 읽는 중\n"

#: common.c:133
msgid "reading user-defined tables\n"
msgstr "사용자 정의 테이블들을 읽는 중\n"

#: common.c:137
msgid "reading table inheritance information\n"
msgstr "테이블 상속 정보를 읽는 중\n"

#: common.c:141
msgid "reading rewrite rules\n"
msgstr "룰(rule) 읽는 중\n"

#: common.c:145
msgid "reading type casts\n"
msgstr "형변환자(type cast)들을 읽는 중\n"

#: common.c:150
msgid "finding inheritance relationships\n"
msgstr "상속 관계를 조사중\n"

#: common.c:154
msgid "reading column info for interesting tables\n"
msgstr "재미난 테이블들(interesting tables)을 위해 칼럼 정보를 읽는 중\n"

#: common.c:158
msgid "flagging inherited columns in subtables\n"
msgstr "하위 테이블에서 상속된 칼럼 구분중\n"

#: common.c:162
msgid "reading indexes\n"
msgstr "인덱스들을 읽는 중\n"

#: common.c:166
msgid "reading constraints\n"
msgstr "제약조건들을 읽는 중\n"

#: common.c:170
msgid "reading triggers\n"
msgstr "트리거들을 읽는 중\n"

#: common.c:421
#: common.c:553
#: common.c:587
#: pg_backup_archiver.c:619
#: pg_backup_archiver.c:970
#: pg_backup_archiver.c:1084
#: pg_backup_archiver.c:1522
#: pg_backup_archiver.c:1672
#: pg_backup_archiver.c:1705
#: pg_backup_custom.c:141
#: pg_backup_custom.c:146
#: pg_backup_custom.c:152
#: pg_backup_custom.c:167
#: pg_backup_custom.c:544
#: pg_backup_db.c:157
#: pg_backup_db.c:233
#: pg_backup_files.c:112
#: pg_backup_tar.c:168
#: pg_backup_tar.c:960
msgid "out of memory\n"
msgstr "메모리 부족\n"

#: common.c:728
#, c-format
msgid "failed sanity check, parent OID %u of table \"%s\" (OID %u) not found\n"
msgstr "안전 검사 실패, OID %u인 부모 객체가 없음. 해당 테이블 \"%s\" (OID %u)\n"

#: common.c:770
msgid "could not parse numeric array: too many numbers\n"
msgstr "숫자 배열을 분석할 수 없음: 너무 숫자가 있습니다\n"

#: common.c:785
msgid "could not parse numeric array: invalid character in number\n"
msgstr "숫자 배열을 분석할 수 없음: 숫자안에 이상한 글자가 있습니다\n"

#: pg_backup_archiver.c:45
msgid "archiver"
msgstr "아카이버"

#: pg_backup_archiver.c:126
msgid "could not close output archive file\n"
msgstr "출력 자료 파일을 닫을 수 없음\n"

#: pg_backup_archiver.c:153
msgid "-C and -c are incompatible options\n"
msgstr "-C 옵션과 -c 옵션은 함께 사용될 수 없습니다\n"

#: pg_backup_archiver.c:160
msgid "connecting to database for restore\n"
msgstr "리스토어 작업을 위해 데이터베이스에 접속합니다\n"

#: pg_backup_archiver.c:162
msgid "direct database connections are not supported in pre-1.3 archives\n"
msgstr "pre-1.3 archive에서 직통 데이터베이스 접속은 지원되지 않습니다\n"

#: pg_backup_archiver.c:205
msgid "implied data-only restore\n"
msgstr "암시된 자료만 복원하기 - 아주 나쁜 번역\n"

#: pg_backup_archiver.c:238
#, c-format
msgid "dropping %s %s\n"
msgstr "%s %s 삭제하는 중\n"

#: pg_backup_archiver.c:264
#: pg_backup_archiver.c:266
#, c-format
msgid "warning from original dump file: %s\n"
msgstr "원본 덤프 파일에서 발생한 경고: %s\n"

#: pg_backup_archiver.c:273
#, c-format
msgid "creating %s %s\n"
msgstr "%s %s 만드는 중\n"

#: pg_backup_archiver.c:281
#, c-format
msgid "connecting to new database \"%s\"\n"
msgstr "\"%s\" 새 데이터베이스에 접속합니다\n"

#: pg_backup_archiver.c:306
msgid "cannot restore from compressed archive (not configured for compression support)\n"
msgstr "압축된 자료파일을 복원용으로 사용할 수 없습니다(압축기능을 지원하지 않고 컴파일되었음)\n"

#: pg_backup_archiver.c:326
msgid "WARNING: skipping large-object restoration\n"
msgstr "경고: large-object 리스토어 작업은 건너뜁니다\n"

#: pg_backup_archiver.c:336
#, c-format
msgid "restoring data for table \"%s\"\n"
msgstr "\"%s\" 테이블의 자료를 리스토어 하는 중\n"

#: pg_backup_archiver.c:368
#: pg_backup_archiver.c:454
#, c-format
msgid "fixing up large-object cross-reference for \"%s\"\n"
msgstr "\"%s\" 위한 large-object 상호 참조 정보를 수정합니다\n"

#: pg_backup_archiver.c:379
#, c-format
msgid "executing %s %s\n"
msgstr "실행중: %s %s\n"

#: pg_backup_archiver.c:399
#, c-format
msgid "setting owner and privileges for %s %s\n"
msgstr "%s %s에 소유주와 접근권한을 지정하는 중\n"

#: pg_backup_archiver.c:517
msgid "disabling triggers\n"
msgstr "트리거 작동을 비활성화 합니다\n"

#: pg_backup_archiver.c:556
msgid "enabling triggers\n"
msgstr "트리거 작동을 활성화 합니다\n"

#: pg_backup_archiver.c:591
msgid "internal error -- WriteData cannot be called outside the context of a DataDumper routine\n"
msgstr "내부 오류 -- WriteData가 DataDumper 루틴 영역 밖에서 호출 될 수 없습니다\n"

#: pg_backup_archiver.c:734
msgid "large-object output not supported in chosen format\n"
msgstr "선택한 파일 형태로는 large-object를 덤프할 수 없습니다\n"

#: pg_backup_archiver.c:774
#: pg_backup_archiver.c:862
msgid "committing large-object transactions\n"
msgstr "large-object 트랜잭션을 commit 합니다\n"

#: pg_backup_archiver.c:784
#, c-format
msgid "restored %d large objects\n"
msgstr "%d개의 large object가 리스토어되었습니다\n"

#: pg_backup_archiver.c:801
msgid "cannot restore large objects without a database connection\n"
msgstr "데이터베이스 접속하지 않고는 large object를 복원할 수 없습니다\n"

#: pg_backup_archiver.c:815
msgid "starting large-object transactions\n"
msgstr "large-object 트랜잭션을 시작합니다\n"

#: pg_backup_archiver.c:823
msgid "could not create large object\n"
msgstr "large object를 만들 수 없음\n"

#: pg_backup_archiver.c:825
#, c-format
msgid "restoring large object with OID %u as %u\n"
msgstr "OID %u large object를 %u 객체로 복원합니다\n"

#: pg_backup_archiver.c:831
msgid "could not open large object\n"
msgstr "large object를 열 수 없음\n"

#: pg_backup_archiver.c:846
#, c-format
msgid "wrote remaining %lu bytes of large-object data (result = %lu)\n"
msgstr "large-object 자료의 남아있는 %lu 바이트를 기록했습니다 (결과값 = %lu)\n"

#: pg_backup_archiver.c:849
#: pg_backup_archiver.c:1141
#, c-format
msgid "could not write to large object (result: %lu, expected: %lu)\n"
msgstr "large object를 쓸 수 없음 (결과값: %lu, 예상값: %lu)\n"

#: pg_backup_archiver.c:895
msgid "could not open TOC file\n"
msgstr "TOC 파일을 열 수 없음\n"

#: pg_backup_archiver.c:916
#, c-format
msgid "WARNING: line ignored: %s\n"
msgstr "경고: 줄 무시됨: %s\n"

#: pg_backup_archiver.c:923
#, c-format
msgid "could not find entry for ID %d\n"
msgstr "%d ID에 대한 항목을 찾지 못했음\n"

#: pg_backup_archiver.c:933
#: pg_backup_files.c:156
#: pg_backup_files.c:439
#, c-format
msgid "could not close TOC file: %s\n"
msgstr "TOC 파일을 닫을 수 없음: %s\n"

#: pg_backup_archiver.c:1032
#: pg_backup_files.c:130
#, c-format
msgid "could not open output file: %s\n"
msgstr "출력 파일을 열 수 없음: %s\n"

#: pg_backup_archiver.c:1048
#, c-format
msgid "could not close output file: %s\n"
msgstr "출력 파일을 닫을 수 없음: %s\n"

#: pg_backup_archiver.c:1137
#, c-format
msgid "wrote %lu bytes of large object data (result = %lu)\n"
msgstr "large object 자료의 %lu 바이트를 기록했음(결과값 = %lu)\n"

#: pg_backup_archiver.c:1159
msgid "could not write to compressed archive\n"
msgstr "압축된 아카이브에 기록할 수 없음\n"

#: pg_backup_archiver.c:1167
msgid "could not write to custom output routine\n"
msgstr "custom 출력 루틴에 기록할 수 없음\n"

#: pg_backup_archiver.c:1182
#, c-format
msgid "could not write to output file (%lu != %lu)\n"
msgstr "출력 파일에 기록할 수 없음 (%lu != %lu)\n"

#: pg_backup_archiver.c:1267
msgid "Error while INITIALIZING:\n"
msgstr "초기화 작업 중 오류:\n"

#: pg_backup_archiver.c:1272
msgid "Error while PROCESSING TOC:\n"
msgstr "TOC 처리하는 중 오류:\n"

#: pg_backup_archiver.c:1277
msgid "Error while FINALIZING:\n"
msgstr "뒷 마무리 작업 중 오류:\n"

#: pg_backup_archiver.c:1282
#, c-format
msgid "Error from TOC entry %d; %u %u %s %s %s\n"
msgstr "%d TOC 항목에서 오류발견; %u %u %s %s %s\n"

#: pg_backup_archiver.c:1415
#, c-format
msgid "Unexpected data offset flag %d\n"
msgstr "예상치 못한 자료 옵셋 플래그 %d\n"

#: pg_backup_archiver.c:1428
msgid "file offset in dump file is too large\n"
msgstr "덤프 파일에서 파일 옵셋 값이 너무 큽니다\n"

#: pg_backup_archiver.c:1540
msgid "attempting to ascertain archive format\n"
msgstr "아카이브 포멧을 결정합니다\n"

#: pg_backup_archiver.c:1560
#: pg_backup_files.c:148
#, c-format
msgid "could not open input file: %s\n"
msgstr "입력 파일을 열 수 없음: %s\n"

#: pg_backup_archiver.c:1567
#, c-format
msgid "could not read input file: %s\n"
msgstr "입력 파일을 읽을 수 없음: %s\n"

#: pg_backup_archiver.c:1569
#, c-format
msgid "input file is too short (read %lu, expected 5)\n"
msgstr "입력 파일이 너무 짧습니다 (%lu 읽었음, 예상치 5)\n"

#: pg_backup_archiver.c:1622
msgid "input file does not appear to be a valid archive (too short?)\n"
msgstr "입력 파일에서 타당한 아카이브를 찾을 수 없습니다(너무 짧은지?)\n"

#: pg_backup_archiver.c:1625
msgid "input file does not appear to be a valid archive\n"
msgstr "입력 파일에서 타당한 아카이브를 찾을 수 없습니다\n"

#: pg_backup_archiver.c:1643
#, c-format
msgid "read %lu bytes into lookahead buffer\n"
msgstr "%lu 바이트를 lookahead 버퍼로 읽어드림\n"

#: pg_backup_archiver.c:1650
#, c-format
msgid "could not close the input file after reading header: %s\n"
msgstr "헤더를 읽은 뒤에 입력 파일을 닫을 수 없음: %s\n"

#: pg_backup_archiver.c:1667
#, c-format
msgid "allocating AH for %s, format %d\n"
msgstr "%s 위한 AH를 할당하는 중, 포멧 %d\n"

#: pg_backup_archiver.c:1721
#, c-format
msgid "archive format is %d\n"
msgstr "아카이브 파일 형태 = %d\n"

#: pg_backup_archiver.c:1749
#, c-format
msgid "unrecognized file format \"%d\"\n"
msgstr "알 수 없는 파일 포멧: \"%d\"\n"

#: pg_backup_archiver.c:1877
#, c-format
msgid "entry ID %d out of range -- perhaps a corrupt TOC\n"
msgstr "%d ID 항목은 범위를 벗어났음 -- TOC 정보가 손상된 듯 합니다\n"

#: pg_backup_archiver.c:1962
#, c-format
msgid "read TOC entry %d (ID %d) for %s %s\n"
msgstr "%d TOC 항목 (%d ID) 읽기, 해당객체: %s %s\n"

#: pg_backup_archiver.c:2124
#, c-format
msgid "could not set session user to \"%s\": %s"
msgstr "\"%s\" 사용자로 세션 사용자를 지정할 수 없음: %s"

#: pg_backup_archiver.c:2569
msgid "WARNING: requested compression not available in this installation -- archive will be uncompressed\n"
msgstr "경고: 요청한 압축 기능은 이 설치판에서는 사용할 수 없습니다 -- 자료 파일은 압축 없이 만들어질 것입니다\n"

#: pg_backup_archiver.c:2604
msgid "did not find magic string in file header\n"
msgstr "파일 헤더에서 매직 문자열을 찾지 못했습니다\n"

#: pg_backup_archiver.c:2618
#, c-format
msgid "unsupported version (%d.%d) in file header\n"
msgstr "파일 헤더에 있는 %d.%d 버전은 지원되지 않습니다\n"

#: pg_backup_archiver.c:2623
#, c-format
msgid "sanity check on integer size (%lu) failed\n"
msgstr "정수 크기 (%lu) 안전성 검사 실패\n"

#: pg_backup_archiver.c:2627
msgid "WARNING: archive was made on a machine with larger integers, some operations may fail\n"
msgstr "경고: 이 아카이브는 큰 정수를 지원하는 시스템에서 만들어졌습니다. 그래서 몇 동작이 실패할 수도 있습니다.\n"

#: pg_backup_archiver.c:2637
#, c-format
msgid "expected format (%d) differs from format found in file (%d)\n"
msgstr "예상되는 포멧 (%d)와 발견된 파일 포멧 (%d)이 서로 틀립니다\n"

#: pg_backup_archiver.c:2653
msgid "WARNING: archive is compressed, but this installation does not support compression -- no data will be available\n"
msgstr "경고: 아카이브는 압축되어있지만, 이 프로그램에서는 압축기능을 지원하지 못합니다 -- 이 안에 있는 자료를 모두 사용할 수 없습니다.\n"

#: pg_backup_archiver.c:2671
msgid "WARNING: invalid creation date in header\n"
msgstr "경고: 헤더에 잘못된 생성 날짜가 있음\n"

#: pg_backup_custom.c:97
msgid "custom archiver"
msgstr "custom 아카이버"

#: pg_backup_custom.c:180
#: pg_backup_custom.c:191
#, c-format
msgid "could not open archive file \"%s\": %s\n"
msgstr "\"%s\" 자료 파일을 열 수 없음: %s\n"

#: pg_backup_custom.c:389
msgid "invalid OID for large object\n"
msgstr "잘못된 large object용 OID\n"

#: pg_backup_custom.c:447
msgid "Dumping a specific TOC data block out of order is not supported without ID on this input stream (fseek required)\n"
msgstr "순차적이지 않은 특정 TOC 자료 블럭을 덤프하는 것은 이 입력 스트림에서 ID 없이는 지원되지 않습니다 (fseek 요구됨)\n"

#: pg_backup_custom.c:462
#, c-format
msgid "unrecognized data block type (%d) while searching archive\n"
msgstr "아카이브 검색하는 동안 알 수 없는 자료 블럭 형태(%d)를 발견함\n"

#: pg_backup_custom.c:473
#, c-format
msgid "error during file seek: %s\n"
msgstr "파일 seek 작업하는 도중 오류가 발생했습니다: %s\n"

#: pg_backup_custom.c:480
#, c-format
msgid "found unexpected block ID (%d) when reading data -- expected %d\n"
msgstr "자료를 읽는 동안 예상치 못한 ID (%d) 발견됨 -- 예상값 %d\n"

#: pg_backup_custom.c:491
msgid "large objects cannot be loaded without a database connection\n"
msgstr "데이터베이스에 접속하지 않고, large object를 로드할 수는 없습니다\n"

#: pg_backup_custom.c:497
#, c-format
msgid "unrecognized data block type %d while restoring archive\n"
msgstr "아카이브 복원하는 중에, 알 수 없는 자료 블럭 형태 %d 를 발견함\n"

#: pg_backup_custom.c:531
#: pg_backup_custom.c:893
#, c-format
msgid "could not initialize compression library: %s\n"
msgstr "압축 라이브러리를 초기화 할 수 없음: %s\n"

#: pg_backup_custom.c:553
#: pg_backup_custom.c:676
#, c-format
msgid "could not read data block -- expected %lu, got %lu\n"
msgstr "자료 블럭을 읽을 수 없음 -- %lu 기대치, %lu 처리값\n"

#: pg_backup_custom.c:571
#: pg_backup_custom.c:601
#, c-format
msgid "could not uncompress data: %s\n"
msgstr "자료 압축을 풀 수 없습니다: %s\n"

#: pg_backup_custom.c:607
#, c-format
msgid "could not close compression library: %s\n"
msgstr "압축 라이브러리를 닫을 수 없음: %s\n"

#: pg_backup_custom.c:704
#, c-format
msgid "could not write byte: %s\n"
msgstr "바이트 쓸 수 없음: %s\n"

#: pg_backup_custom.c:748
#: pg_backup_files.c:414
#, c-format
msgid "write error in _WriteBuf (%lu != %lu)\n"
msgstr "_WriteBuf 에서 쓰기 오류 (%lu !- %lu)\n"

#: pg_backup_custom.c:819
#, c-format
msgid "could not close archive file: %s\n"
msgstr "자료 파일을 닫을 수 없음: %s\n"

#: pg_backup_custom.c:842
msgid "WARNING: ftell mismatch with expected position -- ftell used\n"
msgstr "경고: ftell 값과, 예상되는 위치값이 틀림 -- ftell 값이 사용됨\n"

#: pg_backup_custom.c:925
#, c-format
msgid "could not compress data: %s\n"
msgstr "자료를 압축할 수 없음: %s\n"

#: pg_backup_custom.c:945
msgid "could not write compressed chunk\n"
msgstr "압축된 chunk를 쓸 수 없음\n"

#: pg_backup_custom.c:959
msgid "could not write uncompressed chunk\n"
msgstr "압축 안된 chunk를 쓸 수 없음\n"

#: pg_backup_custom.c:1005
#, c-format
msgid "could not close compression stream: %s\n"
msgstr "압축 스트림을 닫을 수 없음: %s\n"

#: pg_backup_db.c:31
msgid "archiver (db)"
msgstr "덤프받을 DB"

#: pg_backup_db.c:68
msgid "could not get server_version from libpq\n"
msgstr "libpq에서 server_verion 값을 구할 수 없음\n"

#: pg_backup_db.c:79
#, c-format
msgid "server version: %s; %s version: %s\n"
msgstr "서버 버전: %s; %s 버전: %s\n"

#: pg_backup_db.c:82
msgid "proceeding despite version mismatch\n"
msgstr "버전이 서로 틀려도 그냥 진행합니다\n"

#: pg_backup_db.c:84
msgid "aborting because of version mismatch  (Use the -i option to proceed anyway.)\n"
msgstr "버전이 맞지 않아 중지합니다 (강제로 진행하려면, -i 옵션을 사용하세요)\n"

#: pg_backup_db.c:151
#, c-format
msgid "connecting to database \"%s\" as user \"%s\"\n"
msgstr "\"%s\" 데이터베이스를 \"%s\" 사용자로 접속합니다\n"

#: pg_backup_db.c:155
#: pg_backup_db.c:187
#: pg_backup_db.c:231
#: pg_backup_db.c:260
#: pg_dumpall.c:941
#: pg_dumpall.c:967
msgid "Password: "
msgstr "비밀번호: "

#: pg_backup_db.c:167
msgid "failed to reconnect to database\n"
msgstr "데이터베이스 재접속 실패\n"

#: pg_backup_db.c:190
#, c-format
msgid "could not reconnect to database: %s"
msgstr "데이터베이스 재접속을 할 수 없음: %s"

#: pg_backup_db.c:227
msgid "already connected to a database\n"
msgstr "데이터베이스에 이미 접속해 있음\n"

#: pg_backup_db.c:250
msgid "failed to connect to database\n"
msgstr "데이터베이스 접속 실패\n"

#: pg_backup_db.c:269
#, c-format
msgid "connection to database \"%s\" failed: %s"
msgstr "\"%s\" 데이터베이스에 접속 할 수 없음: %s"

#: pg_backup_db.c:284
#, c-format
msgid "%s"
msgstr "%s"

#: pg_backup_db.c:313
#, c-format
msgid "%s: no result from server\n"
msgstr "%s: 서버에서 아무런 결과값도 보내주지 않았음\n"

#: pg_backup_db.c:320
msgid "COPY command executed in non-primary connection\n"
msgstr "COPY 명령이 기본 접속이 아닌데서 실행되었습니다\n"

#: pg_backup_db.c:410
msgid "error returned by PQputline\n"
msgstr "PQputline에 의해서 오류가 반환되었음\n"

#: pg_backup_db.c:421
msgid "error returned by PQendcopy\n"
msgstr "PQendcopy에 의해서 오류가 반환되었음\n"

#: pg_backup_db.c:481
msgid "could not execute query"
msgstr "쿼리를 실행 할 수 없음"

#: pg_backup_db.c:701
#, c-format
msgid "could not find OID columns of table \"%s\": %s"
msgstr "\"%s\" 테이블에서 OID 칼럼을 찾을 수 없음: %s"

#: pg_backup_db.c:707
#, c-format
msgid "no OID type columns in table %s\n"
msgstr "%s 테이블에는 OID 자료형 칼럼이 없습니다\n"

#: pg_backup_db.c:721
#, c-format
msgid "fixing large object cross-references for %s.%s\n"
msgstr "%s.%s 위한 large object 상호 참조를 고칩니다\n"

#: pg_backup_db.c:760
#, c-format
msgid "SQL: %s\n"
msgstr "SQL: %s\n"

#: pg_backup_db.c:765
#, c-format
msgid "could not update column \"%s\" of table \"%s\": %s"
msgstr "\"%s\" 칼럼을 \"%s\" 테이블에서 갱신할 수 없음: %s"

#: pg_backup_db.c:770
#, c-format
msgid "error while updating column \"%s\" of table \"%s\": %s"
msgstr "\"%s\" 칼럼을 \"%s\" 테이블에서 갱신하는 동안 오류 발생: %s"

#: pg_backup_db.c:793
msgid "creating table for large object cross-references\n"
msgstr "large object 상호 참조 테이블을 만듭니다\n"

#: pg_backup_db.c:796
msgid "could not create large object cross-reference table"
msgstr "large object 상호 참조 테이블을 만들 수 없음"

#: pg_backup_db.c:806
msgid "creating index for large object cross-references\n"
msgstr "large object 상호 참조 테이블에 인덱스를 만듭니다\n"

#: pg_backup_db.c:810
msgid "could not create index on large object cross-reference table"
msgstr "large object 상호 참조 테이블에 인덱스를 만들 수 없음"

#: pg_backup_db.c:823
msgid "could not create large object cross-reference entry"
msgstr "large object 상호 참조 항목을 만들 수 없음"

#: pg_backup_db.c:835
msgid "could not start database transaction"
msgstr "데이터베이스 트랜잭션을 시작할 수 없음"

#: pg_backup_db.c:849
msgid "could not start transaction for large object cross-references"
msgstr "large object 상호 참조를 위한 트랜잭션을 시작할 수 없음"

#: pg_backup_db.c:862
msgid "could not commit database transaction"
msgstr "데이터베이스 트랜잭션을 commit 할 수 없음"

#: pg_backup_db.c:875
msgid "could not commit transaction for large object cross-references"
msgstr "large object 상호 참조를 위한 트랜잭션을 commit 할 수 없음"

#: pg_backup_files.c:69
msgid "file archiver"
msgstr "file 아카이버"

#: pg_backup_files.c:120
msgid ""
"WARNING:\n"
"  This format is for demonstration purposes; it is not intended for\n"
"  normal use. Files will be written in the current working directory.\n"
msgstr ""
"경고:\n"
"  이 포멧은 시안용입니다; 일반적인 작업에서는 사용하지 마십시오\n"
"  출력 결과는 현재 작업 디렉토리에 만들어질 것입니다.\n"

#: pg_backup_files.c:246
msgid "could not open data file for output\n"
msgstr "출력용 자료 파일을 열 수 없음\n"

#: pg_backup_files.c:266
msgid "could not close data file\n"
msgstr "자료 파일을 닫을 수 없음\n"

#: pg_backup_files.c:290
msgid "could not open data file for input\n"
msgstr "입력용 자료 파일을 열 수 없음\n"

#: pg_backup_files.c:299
msgid "could not close data file after reading\n"
msgstr "자료 파일을 읽은 뒤에 닫을 수 없음\n"

#: pg_backup_files.c:362
#, c-format
msgid "could not open large object TOC for input: %s\n"
msgstr "입력용 large object TOC 파일을 열 수 없음: %s\n"

#: pg_backup_files.c:375
#: pg_backup_files.c:545
#, c-format
msgid "could not close large object TOC file: %s\n"
msgstr "large object TOC 파일을 닫을 수 없음: %s\n"

#: pg_backup_files.c:387
msgid "could not write byte\n"
msgstr "바이트를 쓸 수 없음\n"

#: pg_backup_files.c:473
#, c-format
msgid "could not open large object TOC for output: %s\n"
msgstr "출력용 large object TOC 파일을 닫을 수 없음: %s\n"

#: pg_backup_files.c:493
#: pg_backup_tar.c:884
#, c-format
msgid "invalid OID for large object (%u)\n"
msgstr "잘못된 large object OID: %u\n"

#: pg_backup_files.c:512
msgid "could not open large object file\n"
msgstr "large object 파일을 열 수 없음\n"

#: pg_backup_files.c:527
msgid "could not close large object file\n"
msgstr "large object 파일을 닫을 수 없음\n"

#: pg_backup_null.c:55
msgid "this format cannot be read\n"
msgstr "이 파일 형태는 읽을 수 없음\n"

#: pg_backup_tar.c:105
msgid "tar archiver"
msgstr "tar 아카이버"

#: pg_backup_tar.c:183
#, c-format
msgid "could not open TOC file for output: %s\n"
msgstr "출력용 TOC 파일을 열 수 없음: %s\n"

#: pg_backup_tar.c:208
msgid "compression not supported by tar output format\n"
msgstr "tar 출력 포멧에서 압축 기능을 지원하지 않음\n"

#: pg_backup_tar.c:220
#, c-format
msgid "could not open TOC file for input: %s\n"
msgstr "입력용 TOC 파일을 열 수 없음: %s\n"

#: pg_backup_tar.c:341
#, c-format
msgid "could not find file %s in archive\n"
msgstr "아카이브에서 %s 파일을 찾을 수 없음\n"

#: pg_backup_tar.c:352
msgid "compression support is disabled in this format\n"
msgstr "이 포멧에서는 압축 기능 지원이 비활성화 되었습니다\n"

#: pg_backup_tar.c:367
#, c-format
msgid "could not generate temporary file name: %s\n"
msgstr "임시 파일 이름을 짓지 못했습니다: %s\n"

#: pg_backup_tar.c:376
msgid "could not open temporary file\n"
msgstr "임시 파일을 열 수 없음\n"

#: pg_backup_tar.c:406
msgid "could not close tar member\n"
msgstr "tar 맴버를 닫지 못했습니다\n"

#: pg_backup_tar.c:506
msgid "internal error -- neither th nor fh specified in tarReadRaw()\n"
msgstr "내부 오류 - tarReadRaw()에서 th, fh 둘다 지정하지 않았음\n"

#: pg_backup_tar.c:510
#, c-format
msgid "requested %d bytes, got %d from lookahead and %d from file\n"
msgstr "%d 바이트가 요구되었음, lookahead에서 %d, 파일에서 %d 처리했음\n"

#: pg_backup_tar.c:549
#, c-format
msgid "could not write to tar member (wrote %lu, attempted %lu)\n"
msgstr "tar 맴버에 쓸 수 없음 (%lu 기록됨, %lu 시도됨)\n"

#: pg_backup_tar.c:638
#, c-format
msgid "invalid COPY statement -- could not find \"copy\" in string \"%s\"\n"
msgstr "잘못된 COPY 구문 -- \"%s\" 문자열에서 \"copy\"를 찾지 못했음\n"

#: pg_backup_tar.c:656
#, c-format
msgid "invalid COPY statement -- could not find \"from stdin\" in string \"%s\" starting at position %lu\n"
msgstr "잘못된 COPY 구문 -- \"%s\" 문자열(위치: %lu)에서 \"from stdin\"을 찾지 못했음\n"

#: pg_backup_tar.c:692
#, c-format
msgid "restoring large object OID %u\n"
msgstr "%u OID large object를 리스토어합니다\n"

#: pg_backup_tar.c:829
msgid "could not write null block at end of tar archive\n"
msgstr "tar 아카이브의 끝에 null 블럭을 쓸 수 없음\n"

#: pg_backup_tar.c:1027
msgid "archive member too large for tar format\n"
msgstr "아카이브 맴버가 tar 포멧에서 쓰기에는 너무 큽니다\n"

#: pg_backup_tar.c:1037
#, c-format
msgid "write error appending to tar archive (wrote %lu, attempted %lu)\n"
msgstr "tar 아카이브에 추가로 쓰기 오류 (%lu 기록됨, %lu 시도됨)\n"

#: pg_backup_tar.c:1043
#, c-format
msgid "could not close tar member: %s\n"
msgstr "tar 맴버를 닫을 수 없음: %s\n"

#: pg_backup_tar.c:1052
#, c-format
msgid "actual file length (%s) does not match expected (%s)\n"
msgstr "실재 파일 길이(%s)와 예상되는 값(%s)이 틀립니다\n"

#: pg_backup_tar.c:1060
msgid "could not output padding at end of tar member\n"
msgstr "tar 맴버의 끝에 padding(?)을 출력할 수 없습니다\n"

#: pg_backup_tar.c:1089
#, c-format
msgid "moving from position %s to next member at file position %s\n"
msgstr "%s 위치에서 다음 맴버로 이동합니다, 해당 파일 위치 %s\n"

#: pg_backup_tar.c:1100
#, c-format
msgid "now at file position %s\n"
msgstr "새로 이동된 파일 위치: %s\n"

#: pg_backup_tar.c:1109
#: pg_backup_tar.c:1136
#, c-format
msgid "could not find header for file %s in tar archive\n"
msgstr "tar 아카이브에서 %s 파일을 위한 헤더를 찾을 수 없음\n"

#: pg_backup_tar.c:1120
#, c-format
msgid "skipping tar member %s\n"
msgstr "%s tar 맴버는 건너뜁니다\n"

#: pg_backup_tar.c:1124
#, c-format
msgid "dumping data out of order is not supported in this archive format: %s is required, but comes before %s in the archive file.\n"
msgstr "순서를 넘어서는 자료 덤프 작업은 이 아카이브 포멧에서는 지원하지 않습니다: %s 요구되었지만, 이 아카이브 파일에서는 %s 전에 옵니다\n"

#: pg_backup_tar.c:1172
#, c-format
msgid "mismatch in actual vs. predicted file position (%s vs. %s)\n"
msgstr "파일 위치가 실재 위치 (%s)와 예상되는 위치 (%s)가 서로 틀립니다\n"

#: pg_backup_tar.c:1187
#, c-format
msgid "incomplete tar header found (%lu bytes)\n"
msgstr "완성되지 못한 tar 헤더가 발견되었음 (%lu bytes)\n"

#: pg_backup_tar.c:1222
#, c-format
msgid "TOC Entry %s at %s (length %lu, checksum %d)\n"
msgstr "TOC Entry %s at %s (length %lu, checksum %d)\n"

#: pg_backup_tar.c:1232
#, c-format
msgid "corrupt tar header found in %s (expected %d, computed %d) file position %s\n"
msgstr "%s 안에 손상된 tar 헤더 발견 (예상치 %d, 계산된 값 %d), 파일 위치 %s\n"

#: pg_backup_tar.c:1325
msgid "could not write tar header\n"
msgstr "tar header 정보를 쓸 수 없음\n"

#: pg_restore.c:283
#, c-format
msgid "%s: cannot specify both -d and -f output\n"
msgstr "%s: -d 옵션과 -f 옵션을 함께 지정할 수는 없습니다.\n"

#: pg_restore.c:344
#, c-format
msgid "WARNING: errors ignored on restore: %d\n"
msgstr "경고: 복원작업에서의 오류들이 무시되었음: %d\n"

#: pg_restore.c:358
#, c-format
msgid ""
"%s restores a PostgreSQL database from an archive created by pg_dump.\n"
"\n"
msgstr ""
"%s 프로그램은 pg_dump로 만들어진 자료파일로 PostgreSQL 데이터베이스에\n"
"그 자료를 일괄 입력합니다.\n"
"\n"

#: pg_restore.c:360
#, c-format
msgid "  %s [OPTION]... [FILE]\n"
msgstr "  %s [옵션]... [파일]\n"

#: pg_restore.c:363
msgid "  -d, --dbname=NAME        connect to database name\n"
msgstr "  -d, --dbname=NAME        접속할 데이터베이스 이름\n"

#: pg_restore.c:365
msgid "  -F, --format=c|t         specify backup file format\n"
msgstr "  -F, --format=c|t         백업 파일 형태 지정\n"

#: pg_restore.c:366
msgid "  -i, --ignore-version     proceed even when server version mismatches\n"
msgstr "  -i, --ignore-version     서버 버전이 틀려도 무시하고 진행함\n"

#: pg_restore.c:367
msgid "  -l, --list               print summarized TOC of the archive\n"
msgstr "  -l, --list               자료의 요약된 목차를 보여줌\n"

#: pg_restore.c:372
msgid ""
"\n"
"Options controlling the restore:\n"
msgstr ""
"\n"
"리스토어 처리를 위한 옵션들:\n"

#: pg_restore.c:373
msgid "  -a, --data-only          restore only the data, no schema\n"
msgstr "  -a, --data-only          스키마는 빼고 자료만 입력함\n"

#: pg_restore.c:375
msgid "  -C, --create             create the target database\n"
msgstr "  -C, --create             작업 대상 데이터베이스를 만듦\n"

#: pg_restore.c:376
msgid "  -I, --index=NAME         restore named index\n"
msgstr "  -I, --index=NAME         지정한 인덱스 만듦\n"

#: pg_restore.c:377
msgid ""
"  -L, --use-list=FILENAME  use specified table of contents for ordering\n"
"                           output from this file\n"
msgstr "  -L, --use-list=FILENAME  사용할 TOC(자료목차) 파일을 지정함\n"

#: pg_dumpall.c:352
#: pg_restore.c:379
msgid "  -O, --no-owner           skip restoration of object ownership\n"
msgstr "  -O, --no-owner           객체의 소유주 지정 작업 하지 않음\n"

#: pg_restore.c:380
msgid ""
"  -P, --function=NAME(args)\n"
"                           restore named function\n"
msgstr ""
"  -P, --function=NAME(args)\n"
"                           지정한 함수 만듦\n"

#: pg_restore.c:382
msgid "  -s, --schema-only        restore only the schema, no data\n"
msgstr "  -s, --schema-only        자료구조(스키마)만 만듦\n"

#: pg_restore.c:383
msgid ""
"  -S, --superuser=NAME     specify the superuser user name to use for\n"
"                           disabling triggers\n"
msgstr ""
"  -S, --superuser=NAME     트리거 작동을 중지 시킬 수 있는 슈퍼유저\n"
"                           이름을 지정\n"

#: pg_restore.c:385
msgid "  -t, --table=NAME         restore named table\n"
msgstr "  -t, --table=NAME         지정한 테이블 만들고 자료 입력함\n"

#: pg_restore.c:386
msgid "  -T, --trigger=NAME       restore named trigger\n"
msgstr "  -T, --trigger=NAME       지정한 트리거 만듦\n"

#: pg_restore.c:387
msgid "  -x, --no-privileges      skip restoration of access privileges (grant/revoke)\n"
msgstr "  -x, --no-privileges      접근권한(grant/revoke) 지정 안함\n"

#: pg_restore.c:399
msgid "  -e, --exit-on-error      exit on error, default is to continue\n"
msgstr "  -e, --exit-on-error      오류가 생기면 끝냄, 기본은 계속 진행함\n"

#: pg_restore.c:401
msgid ""
"\n"
"If no input file name is supplied, then standard input is used.\n"
"\n"
msgstr ""
"\n"
"사용할 입력 파일을 지정하지 않았다면, 표준 입력(stdin)을 사용합니다.\n"
"\n"

#: pg_dumpall.c:149
#, c-format
msgid ""
"The program \"pg_dump\" is needed by %s but was not found in the\n"
"same directory as \"%s\".\n"
"Check your installation.\n"
msgstr ""
"\"pg_dump\" 프로그램이 %s 작업에서 필요로 하지만, \"%s\" 프로그램이\n"
"있는 같은 디렉토리에서 찾을 수 없습니다.\n"
"설치 상태를 살펴 보십시오.\n"

#: pg_dumpall.c:156
#, c-format
msgid ""
"The program \"pg_dump\" was found by \"%s\"\n"
"but was not the same version as %s.\n"
"Check your installation.\n"
msgstr ""
"\"pg_dump\" 프로그램이 \"%s\" 작업 때문에 찾았지만, \n"
"%s 버전과 서로 틀립니다.\n"
"설치 상태를 살펴 보십시오.\n"

#: pg_dumpall.c:336
#, c-format
msgid ""
"%s extracts a PostgreSQL database cluster into an SQL script file.\n"
"\n"
msgstr ""
"%s 프로그램은 PostgreSQL 데이터베이스 클러스터를 SQL 스크립트 파일로\n"
"추출하는 프로그램입니다.\n"
"\n"

#: pg_dumpall.c:338
#, c-format
msgid "  %s [OPTION]...\n"
msgstr "  %s [옵션]...\n"

#: pg_dumpall.c:341
msgid ""
"  -i, --ignore-version     proceed even when server version mismatches\n"
"                           pg_dumpall version\n"
msgstr ""
"  -i, --ignore-version     pg_dumpall 버전과 서버 버전이 틀려도\n"
"                           작업을 계속 진행함\n"

#: pg_dumpall.c:347
msgid "  -c, --clean              clean (drop) databases prior to create\n"
msgstr "  -c, --clean              작업이 끝나면 모든 데이터베이스를 삭제함\n"

#: pg_dumpall.c:350
msgid "  -g, --globals-only       dump only global objects, no databases\n"
msgstr "  -g, --globals-only       데이터베이스를 제외한 전역 객체들만 덤프함\n"

#: pg_dumpall.c:354
msgid "  -S, --superuser=NAME     specify the superuser user name to use in the dump\n"
msgstr "  -S, --superuser=NAME     덤프 작업을 할 슈퍼유저를 지정\n"

#: pg_dumpall.c:370
msgid ""
"\n"
"The SQL script will be written to the standard output.\n"
"\n"
msgstr ""
"\n"
"SQL 스크립트는 표준출력(stdout)로 출력될 것입니다.\n"
"\n"

#: pg_dumpall.c:570
#, c-format
msgid "%s: could not parse ACL list (%s) for tablespace \"%s\"\n"
msgstr "%s: 테이블스페이스 용 ACL 목록 (%s)을 분석할 수 없음, 해당객체 \"%s\"\n"

#: pg_dumpall.c:702
#, c-format
msgid "%s: could not parse ACL list (%s) for database \"%s\"\n"
msgstr "%s: 데이터베이스 용 ACL 목록 (%s)을 분석할 수 없음, 해당객체: \"%s\"\n"

#: pg_dumpall.c:852
#, c-format
msgid "%s: dumping database \"%s\"...\n"
msgstr "%s: \"%s\" 데이터베이스 덤프 중...\n"

#: pg_dumpall.c:858
#, c-format
msgid "%s: pg_dump failed on database \"%s\", exiting\n"
msgstr "%s: \"%s\" 데이터베이스에서 pg_dump 작업 중에 오류가 발생, 끝냅니다.\n"

#: pg_dumpall.c:913
#, c-format
msgid "%s: running \"%s\"\n"
msgstr "%s: \"%s\" 가동중\n"

#: pg_dumpall.c:954
#, c-format
msgid "%s: could not connect to database \"%s\"\n"
msgstr "%s: \"%s\" 데이터베이스에 접속할 수 없음\n"

#: pg_dumpall.c:977
#, c-format
msgid "%s: could not connect to database \"%s\": %s\n"
msgstr "%s: \"%s\" 데이터베이스에 접속할 수 없음: %s\n"

#: pg_dumpall.c:985
#, c-format
msgid "%s: could not get server version\n"
msgstr "%s: 서버 버전을 알 수 없음\n"

#: pg_dumpall.c:991
#, c-format
msgid "%s: could not parse server version \"%s\"\n"
msgstr "%s: \"%s\" 서버 버전을 분석할 수 없음\n"

#: pg_dumpall.c:1010
#, c-format
msgid "%s: executing %s\n"
msgstr "%s: %s 실행중\n"

#: pg_dumpall.c:1016
#, c-format
msgid "%s: query failed: %s"
msgstr "%s: 쿼리 실패: %s"

#: pg_dumpall.c:1017
#, c-format
msgid "%s: query was: %s\n"
msgstr "%s: 사용한 쿼리: %s\n"

#: ../../port/exec.c:193
#: ../../port/exec.c:307
#: ../../port/exec.c:350
#, c-format
msgid "could not identify current directory: %s"
msgstr "현재 디렉토리를 알 수 없음: %s"

#: ../../port/exec.c:323
#: ../../port/exec.c:359
#, c-format
msgid "could not change directory to \"%s\""
msgstr "\"%s\" 디렉토리로 이동 할 수 없음"

#: ../../port/exec.c:338
#, c-format
msgid "could not read symbolic link \"%s\""
msgstr "\"%s\" 심벌릭 링크를 읽을 수 없음"

#: ../../port/exec.c:569
#, c-format
msgid "child process exited with exit code %d"
msgstr "하위 프로세스가 종료되었음, 종료 코드 %d"

#: ../../port/exec.c:572
#, c-format
msgid "child process was terminated by signal %d"
msgstr "하위 프로세스가 종료되었음, 시그널 %d"

#: ../../port/exec.c:575
#, c-format
msgid "child process exited with unrecognized status %d"
msgstr "하위 프로세스가 종료되었음, 알수 없는 상태 %d"

